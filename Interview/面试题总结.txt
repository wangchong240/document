1、jdk blocking场景什么时候阻塞？
2、blockingmq满了怎么办？
3、excute、submit区别，怎么阻塞主线程？
4、线程池怎么设计？
5、jdk线程池有哪些？
6、aop里this问题？
7、redis key 的哈希设计问题
8、spring 的注入互相依赖问题怎么解决、原理？
9、线程中断问题？
10、sleep和wait区别，为什么一个是object方法一个是thread方法，那个会持锁等待？
11、synthroized锁在jvm里逻辑是怎么实现的
12、volatile原理 和在内存里运作机制  是否原子操作
13、读锁和写锁有什么必要 和在jdk里的应用
14、java内存模型和指令重排优化 和怎么防止指令重排带来的顺序问题
15、进程和线程区别和设计采用问题
16、threadlocal 用法和注意事项  当有子线程的时候怎么办
17、可重入锁原理 jdk相关的应用
18、内存屏障问题
19、cms g1回收器原理 区别
20、final static 修饰变量在jvm内存里的区别
21、jvm调优问题和思路
22、jdk 动态代理 cglib asm javassist 区别和用法
23、	自定义注解使用和场景
24、	cas 自旋锁原理和jdk的对应应用
25、	Springboot模块依赖加载的原理
26、	javassist底层的原理
27、	redis怎么防止请求都集中在一个分片
28、	分布式锁怎么做 setnx怎么用
29、	多线程死锁怎么办
30、	jvm类加载和java spi 
31、	javaagent的使用
32、	快排算法 
33、	hashmap原理 hashtable currenthashtable 原理 区别
34、	流量网关怎么设计
35、	服务治理怎么做
36、	jvm调优什么时候需要把内存调小
37、	微服务和传统服务区别的理解
38、	分布式事务怎么做 当要同时写db和缓存在一个事物里怎么保证数据一致
39、	一个线程怎么等其他线程都执行完再执行
40、	lock锁和synchronize区别 
41、	乐观锁和悲观锁 公平锁和不公平锁 在jdk里的应用
42、	aii nio bio 区别 多路复用机制原理
43、	单例模式怎么写 应用场景
44、	一堆数据怎么用java写分组和排序
45、	SQL怎么查id相同的数据重复的次数
46、	堆和栈溢出怎么办 分别什么时候发生 
47、	jvm gc stp 和fullgc解释一下
48、	两个程序用消息队列通信 怎么避免消息丢失问题
49、	怎么避免redis丢失数据问题 
50、	缓存击穿怎么办 怎么避免
51、	zookeeper 节点为什么设计是单数的

一、spring中的经典面试题：
	1. spring中的Bean是线程安全吗？
		spring中的Bean的初始化，是通过扫描，利用反射new出来的并缓存在IOC容器中，spring并没有对你的bean做任何处理，因此Bean的线程安全问题，是取决于bean的本身，与spring不发生关系。
	2. spring中的Bean是如何被回收的（spring中的bean的生命周期）？
		概念一：spring中的bean的scope（作用域）：singleton（默认）、prototype（原型或多实例）、request、session、application、websocket
		概念二：bean的生命周期：bean的作用域不同，其生命周期就不同
		概念三：GC回收原则，当对象的引用没有指向任何地方时，该对象才被回收
		答案：每个bean的作用域不同，其生命周期就不同，也就被GC回收的时机就不同，例如：spring中默认bean的作用域为singleton（单例）,而bean创建之后，会被存储在IOC容器中，是基于spring上下文的，而IOC容器是随着spring存亡而存亡，因此只要IOC存活，bean就被IOC所引用，因此，在单例模式下，只有spring死亡之后，才会被GC回收


