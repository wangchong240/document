（一）创建型型设计模式

一、简单工厂模式
	
	特点：
		客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心，通常可以通过类名、类的元数据等等，来判断工厂到底创建那种类，只需传入一个正确的参数，就可以获取你所需要的对象 无须知道其创建的细节。例如：Calendar、LoggerFactory等，通常与单例模式结合使用
	缺点：
		工厂类负责创建的对象较少；
		工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断 逻辑，违背开闭原则；
		不易于扩展过于复杂的产品结构。

二、工厂方法模式
	
	工厂方法模式是指定义一个接口，规定了工厂的行为，但是具体行为的实现是由子类工厂来实现，满足了增加产品时，开闭原则
	结构如下：
		抽象工厂（超级工厂） -》 具体工厂（实现自己的行为）

	适用场景：
		1. 创建对象需要大量的重复的代码；
		2. 客户端（应用层）不依赖于产品实例如何创建、实现细节；
		3. 一个类通过其子类来指定创建那个对象，不需要客户端来传参（订单参数构建可以适用）
	缺点：
		1. 类的个数容易过多，增加复杂度；
		2. 增加系统的抽象性和理解难度；
		3. 不能解决多产品族、产品等级的现象。

三、抽象工厂模式

	产品族与产品等级：
		案例1：
			产品族： 海尔有电冰箱、洗衣机、热水器，格力也有电冰箱、洗衣机、热水器，这就是产品族
			产品等级： 电冰箱 有不同的型号，热水器也有，这就是产品等级
		案例2：
			产品族： 咕泡课程能干 录播、笔记、源码
			产品等级：咕泡有java、paython、AI
	实现方式：
		1. 定义顶级接口：规定都有哪些产品族，比如：IVideo void video(), INote void writeNote(), ICode void wirteCode();注意！！！此时的只是返回的结果只是抽象类或者接口，具体的实现是由产品自己定义，也就是实现产品等级
		2. 定义具体的实现工厂：返回具体的带有产品等级的产品，也就实现了，java课程有自己的java录播，Python课程有自己的python录播

	缺点：
		1. 抽象工厂其实不符合开闭原则

四、单例模式
	定义：单例模式是确保一个类在任何情况下都绝对有一个实例，并且提供全局访点。
	有点：保证内存只有一个实例，减少内存开销；可以避免对资源的多重占用
	缺点：没有接口，扩展困难；要扩展单例，只有修改代码，违反开闭原则

	实现方案：
		1. 私有化构造器
		2. 提供全局访问方法
		3. 是否使用懒加载
		4. 保证线程安全
		5. 防止反射破坏单例模式（在私有构造器，添加判断，是否已经创建过实例）
		6. 防止序列化破坏单例模式（在类中重写readResolve方法，但是还是创建2次对象，只不过是通过readResolve方法的返回值给覆盖了，序列化的对象会被GC回收）

	例如：servletConfig、ApplicationConext、servletContext

	实现方法：
		1. 饿汉式单例模式：在单例首次加载就创建实例
			缺点：不能懒加载，浪费空间
			优点：效率高、随类的加载而加载，因此是线程安全的，并且通过final防止反射破坏
		2. 懒汉式单例模式：被外部类调用才创建实例
			优点：能懒加载
			缺点：使用synchronized保证线程安全，效率慢
		3. 双重检查 锁单例模式：主要解决懒汉式线程不安全的问题，并提高效率。
			1. 首先判断是否对象创建过（第一重检查，会提高效率）；
			2. 通过代码块锁住对象创建过程（锁）；
			3. 在锁内部判断对象是否创建过（第二重检查）；
			需要在成员变量前加volatile,解决指令重排序问题
		4. 静态内部类单例模式：静态内部类的特性是，当被调用时，才会加载静态内部类，因此，是懒加载。而JVM规定，多个线程去初始化类时，只允许一个线程初始化类，其余的线程阻塞，而在同一个类加载器下，一个类型只会被初始化一次，因此由JVM保证线程安全
		5. 枚举式单例（注册式单例）：
			5.1 创建实例INSTANCE;
			5.2 定义成员变量；
			5.3 枚举默认没有无参构造器；
			5.4 java编译成class时，用静态代码块实例化实例，因此线程安全；
			5.5 jdk本身就就不允许枚举反射以及反序列化
		6. 容器式单例：
			5.1 私有化构造器
			5.2 提供全局访问点，但是是利用简单工程模式（反射），即需要传入类的全名
			5.3 因为是调用时在创建对象，因此为懒加载
			5.4 通过同步代码块，来保证线程安全，conCurrentHashMap本身是线程安全的，但是全局方法方法是线程不安全的

五、原型模式
	原型模式：是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
	适用场景：
		1、类初始化消耗资源较多。
		2、new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
		3、构造函数比较复杂。
		4、循环体中生产大量对象时。
	深克隆、浅克隆：
		对于非基本类型，深克隆是拷贝本身的值，也就是在堆中重新产生值了，而浅克隆只是拷贝了内存地址值

（二）结构型设计模式

六、代理模式
	1. 静态代理：静态定义代理类，如果被代理类需要功能变化，代理类也需要变化,违背开闭原则，其实就是 显式声明被代理对象
		意义：保护目标对象、增加目标对象；
		实现步骤：
			1. 定义接口（抽象角色），规范被代理对象的所有行为；
			2. 定义被代理类（真实角色）,实现具体行为；
			3. 定义代理类（代理角色）实现抽象角色，并聚合真实角色（应该是以接口来定义，实现代理类互相嵌套，通常用构造器来实例化），自定义附加行为，实现规定的行为。

	2. 动态代理：分离代理行为与被代理对象，达到代理类复用的目的，例如：记录日志代理类、记录时间代理类，几乎每个系统都会用到。
		难点：被代理的对象不一定，即被代理的行为不一定
		方案：不定义具体的代理类，即动态生成代理，这就是动态代理出现的意义
		缺点：被代理类必须实现接口，这是jdk内部实现所要求的

		jdk实现动态代理关键点（生成代理类）：
			目标：动态生成代理类
			0. 被代理类一定要实现接口
			1. 调用jdk的Proxy.newProxyInstance(arg0, arg1, arg3) 生成代理类;
			2. arg0:指定类加载器ClassLoad,将生成的代理类加载到内存中(跟被代理对象用一个类加载器即可)；
			3. arg1:指定代理对象（被代理对象）Class<?>[] inters 实现那些接口；
			4. arg2:调用处理器InvocationHandler,代理类调用被代理类的处理的业务逻辑（即要指定自己的处理逻辑）
			原理：查看生成的动态类，发现代理类基础了Proxy类，动态代理类是通过构造器调用Proxy构造器，将InvocationHandler传递给Proxy，因为我们指定了代理类实现的接口，因此动态代理类会调用接口中的方法，在方法中有吊用了Proxy.h.invoke，即调用自己定义的InvocationHandler.invoke();

			jdk生成代理类，用到了asm操作字节码文件（.class）
			asm:java才能成为动态语言，反射只能读出来，但是改不了

		cglib实现动态代理（被代理可以不实现接口）：
			简述：利用Enhancer来生成代理类，利用自定义接口实现MethodInterceptor,指定代理执行器
			0. 被代理类一定不能被final修饰，原因是，cglib最终生成的代理类，是被代理类的子类
			1. 创建Enhancer enhancer = new Enhancer();
			2. 将被代理类指定为父类，enhancer.setSupperclass(Tank.class);
			3. 定义代理执行器，class TimerMethodInterceptor implements MethodInterceptor{};
			3. 指定代理执行器，enhancer.setCallback(new TimerMethodInterceptor());
			4. 生成代理类，Tank tank = (Tank) enhancer.create();
			5. 执行方法，tank.move();

			cglib 生成代理类，用到了asm操作字节码文件（.class）

		aop:面向切面编程，具体步骤如下：
			1. 定义代理类，@Aspect、@Component,声明我是一个切面类，并且被spring容器化；
			2. 在代理类中定义切点，即我寻找被代理类，以及织入的点
			3. 定义切入时机，@Before、@Around、@After、@Returning.....

（三）行为型设计模式

七、策略模式
	问题引入：利用Comparable排序，要求排序的实体必须实现Comparable接口，并实现抽象方法compare(T o);
			但是现在，我想自定义排序规则，应该怎么办呢？比如：以前是按狗的重量排序，但是现在我想用狗的身高排序，但是还不想违反开闭原则，不想改实现类？
	解决思路：我在用sort比较的时候，将比较策略也传入，代码只需要新创建比较器即可

	Sorter.sort(Objetc[], Comparator);

	例如：订单处理设计为：处理前，处理中，处理后，以处理前为例，我们有可能出现多个订单校验，或者多订单项进行属性处理？？？

	解决思路：1. 定义接口，定义抽象方法（规定处理的行为）
			 2. 定义多个实现类，实现具体的处理逻辑；
			 3. 用spring将实现接口的实现类，注入到客户端，遍历调用每个实现类，来进行规则处理

八、委派模式
	概念：委派模式，对外提供方法，由调用者传入条件，由委派者进行命令分发，
	例如：老板（Boss）给项目经理（Leader）下达任务，项目经理会根据实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工作进度和结果给老板
	重点：是在项目经理会缓存所有员工的信息

	例如：spring的dispatchServlet就是典型的委派模式
	简述：dispatchServlet由调用者调用时，会根据url来委派到具体controller的具体方法；
	实现要点如下： 	1. 在request请求中获取url;
				 	2. 获取url后，会在spring中寻找类似于缓存池的概念（猜测），获取controller的y元数据；
				 	3. 利用反射调用相应的方法（猜测）













