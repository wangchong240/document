创建型型设计模式

一、简单工厂模式
	
	特点：
		客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心，通常可以通过类名、类的元数据等等，来判断工厂到底创建那种类，只需传入一个正确的参数，就可以获取你所需要的对象 无须知道其创建的细节。例如：Calendar、LoggerFactory等，通常与单例模式结合使用
	缺点：
		工厂类负责创建的对象较少；
		工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断 逻辑，违背开闭原则；
		不易于扩展过于复杂的产品结构。

二、工厂方法模式
	
	工厂方法模式是指定义一个接口，规定了工厂的行为，但是具体行为的实现是由子类工厂来实现，满足了增加产品时，开闭原则
	结构如下：
		抽象工厂（超级工厂） -》 具体工厂（实现自己的行为）

	适用场景：
		1. 创建对象需要大量的重复的代码；
		2. 客户端（应用层）不依赖于产品实例如何创建、实现细节；
		3. 一个类通过其子类来指定创建那个对象，不需要客户端来传参（订单参数构建可以适用）
	缺点：
		1. 类的个数容易过多，增加复杂度；
		2. 增加系统的抽象性和理解难度；
		3. 不能解决多产品族、产品等级的现象。

三、抽象工厂模式

	产品族与产品等级：
		案例1：
			产品族： 海尔有电冰箱、洗衣机、热水器，格力也有电冰箱、洗衣机、热水器，这就是产品族
			产品等级： 电冰箱 有不同的型号，热水器也有，这就是产品等级
		案例2：
			产品族： 咕泡课程能干 录播、笔记、源码
			产品等级：咕泡有java、paython、AI
	实现方式：
		1. 定义顶级接口：规定都有哪些产品族，比如：IVideo void video(), INote void writeNote(), ICode void wirteCode();注意！！！此时的只是返回的结果只是抽象类或者接口，具体的实现是由产品自己定义，也就是实现产品等级
		2. 定义具体的实现工厂：返回具体的带有产品等级的产品，也就实现了，java课程有自己的java录播，Python课程有自己的python录播

	缺点：
		1. 抽象工厂其实不符合开闭原则




